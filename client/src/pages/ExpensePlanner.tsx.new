import React, { useState, useMemo, useEffect, useCallback } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useLocation } from "wouter";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import ExpenseList from "@/components/ExpenseList";
import ExpenseCalendar from "@/components/ExpenseCalendar";
import FinancialSummary from "@/components/FinancialSummary";
import AddExpenseModal from "@/components/AddExpenseModal";
import AddIncomeModal from "@/components/AddIncomeModal";
import AddSavingsModal from "@/components/AddSavingsModal";
import EditTransactionModal from "@/components/EditTransactionModal";
import BudgetCoachingCompanion from "@/components/BudgetCoachingCompanion";
import UpcomingExpenses from "@/components/UpcomingExpenses";
import RecurringTransactions from "@/components/RecurringTransactions";
import { Plus } from "lucide-react";
import type { Category, Transaction, TransactionWithCategory, Savings } from "@shared/schema";
import { format, startOfWeek, endOfWeek, startOfMonth, endOfMonth, startOfYear, endOfYear, parseISO } from "date-fns";
import { useToast } from "@/hooks/use-toast";
import { createHardcodedIncomeTransactions } from "@/utils/income-hardcoder";
import { 
  createHardcodedExpenseTransactions,
  isTransactionDeleted as isHardcodedTransactionDeleted,
  deletedHardcodedTransactionIds
} from "@/utils/expense-hardcoder";
import {
  saveEditedTransaction,
  applyUserEditsToTransactions,
  filterDeletedTransactions,
  markTransactionAsDeleted,
  isTransactionDeleted
} from "@/utils/user-preferences";
import { 
  Tooltip, 
  TooltipContent, 
  TooltipProvider, 
  TooltipTrigger 
} from "@/components/ui/tooltip";
import { isMobile } from "@/utils/device-detection";

export default function ExpensePlanner() {
  const [, navigate] = useLocation();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  
  const [showExpenseModal, setShowExpenseModal] = useState(false);
  const [showIncomeModal, setShowIncomeModal] = useState(false);
  const [showSavingsModal, setShowSavingsModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [selectedTransaction, setSelectedTransaction] = useState<TransactionWithCategory | null>(null);
  const [view, setView] = useState<"list" | "calendar">("calendar");
  const [timeframe, setTimeframe] = useState<"month" | "week" | "year">("month");
  const [selectedDate, setSelectedDate] = useState(new Date());
  
  // Calculate date range based on timeframe
  const dateRange = useMemo(() => {
    if (timeframe === "week") {
      return { 
        startDate: startOfWeek(selectedDate, { weekStartsOn: 1 }), 
        endDate: endOfWeek(selectedDate, { weekStartsOn: 1 }) 
      };
    } else if (timeframe === "month") {
      return { 
        startDate: startOfMonth(selectedDate), 
        endDate: endOfMonth(selectedDate) 
      };
    } else {
      return { 
        startDate: startOfYear(selectedDate), 
        endDate: endOfYear(selectedDate) 
      };
    }
  }, [selectedDate, timeframe]);
  
  // Format the date range for display
  const dateRangeText = useMemo(() => {
    if (timeframe === "week") {
      return `${format(dateRange.startDate, "d MMM")} - ${format(dateRange.endDate, "d MMM yyyy")}`;
    } else if (timeframe === "month") {
      return format(selectedDate, "MMMM yyyy");
    } else {
      return format(selectedDate, "yyyy");
    }
  }, [dateRange, selectedDate, timeframe]);
  
  // Fetch transactions 
  const { 
    data: transactions = [], 
    isLoading: isLoadingTransactions 
  } = useQuery<TransactionWithCategory[]>({
    queryKey: ['/api/transactions'],
    staleTime: 0, // Always refetch to ensure fresh data
  });

  // Add transaction mutation
  const addTransaction = useMutation({
    mutationFn: (transactionData: Omit<Transaction, "id">) => {
      return apiRequest('POST', '/api/transactions', transactionData);
    },
    onSuccess: () => {
      // Removed success toast as requested by user
      queryClient.invalidateQueries({ queryKey: ['/api/transactions'] });
      setShowExpenseModal(false);
      setShowIncomeModal(false);
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: `Failed to add transaction: ${error}`,
        variant: "destructive",
      });
    }
  });
  
  // Define the handleDeleteTransaction function first 
  // so it can be used by the mutations - this completely avoids API calls
  // for hardcoded transactions
  const handleDeleteTransaction = (id: number) => {
    console.log(`Handling deletion for transaction ID: ${id}`);
    
    // Find the transaction in the current dataset
    const transaction = transactions.find(t => t.id === id);
    
    // Special handling for "Grocerries" transactions which have known issues
    if (transaction && transaction.title === 'Grocerries') {
      console.log(`[SPECIAL DELETE] Detected Grocerries transaction ID: ${id}`);
      
      // Notify user of special handling
      toast({
        title: "Deleting Grocerries",
        description: "Removing all instances of this recurring transaction...",
      });
      
      // Call the special API handler and do additional cache cleanup
      deleteTransaction.mutate(id, {
        onSuccess: () => {
          console.log(`[GROCERRIES] Successfully deleted Grocerries transaction ${id}`);
          
          // Extra cache cleanup for ALL Grocerries transactions
          const currentQueryData = queryClient.getQueryData<TransactionWithCategory[]>(['/api/transactions']);
          if (currentQueryData) {
            const updatedQueryData = currentQueryData.filter(t => t.title !== 'Grocerries');
            queryClient.setQueryData<TransactionWithCategory[]>(
              ['/api/transactions'],
              updatedQueryData
            );
            console.log(`[GROCERRIES] Cleaned all Grocerries transactions from cache`);
          }
          
          // Force monthly view refresh to ensure everything updates correctly
          const currentDate = new Date(selectedDate);
          const nextMonth = new Date(selectedDate);
          nextMonth.setMonth(nextMonth.getMonth() + 1);
          
          // Force view refresh by changing months quickly
          setTimeout(() => {
            setSelectedDate(nextMonth);
            setTimeout(() => {
              setSelectedDate(currentDate);
            }, 200);
          }, 100);
        }
      });
      
      return; // Skip the rest of the function
    }
    
    // Handle virtual transactions or recurring transactions specially
    const isVirtualTransaction = id >= 970000;
    const isRecurringTransaction = transaction?.isRecurring;
    
    if (isVirtualTransaction || isRecurringTransaction) {
      // For virtual or recurring transactions, implement enhanced client-side deletion
      console.log(`[ENHANCED DELETE] Removing transaction with ID: ${id}, isVirtual: ${isVirtualTransaction}, isRecurring: ${isRecurringTransaction}`);
      
      // Pass the full transaction object for pattern deletion if it's recurring
      markTransactionAsDeleted(id, transaction);
      
      // Show appropriate success message
      toast({
        title: "Success",
        description: isRecurringTransaction 
          ? "Recurring transaction pattern deleted" 
          : "Transaction deleted successfully",
      });
      
      try {
        // Store the current date to return to
        const currentDate = new Date(selectedDate);
        
        // Find and track the removed transaction title
        const transactionToDelete = filteredTransactions.find(t => t.id === id);
        const titleToRemove = transactionToDelete?.title;
        console.log(`Removing transaction: "${titleToRemove}" from UI`);
        
        // Update react-query cache to immediately reflect deletion
        const currentQueryData = queryClient.getQueryData<TransactionWithCategory[]>(['/api/transactions']);
        if (currentQueryData) {
          // Find and remove the transaction from cache
          const updatedQueryData = currentQueryData.filter(t => {
            // If this exact transaction, remove it
            if (t.id === id) return false;
            
            // If this is a recurring pattern transaction, also remove those
            if (isRecurringTransaction && t.title === titleToRemove && t.isExpense === transaction?.isExpense) {
              console.log(`Also removing recurring instance: ${t.id} - ${t.title}`);
              // Mark all related transactions as deleted in localStorage
              markTransactionAsDeleted(t.id, t);
              return false;
            }
            
            return true;
          });
          
          // Update cache
          queryClient.setQueryData<TransactionWithCategory[]>(
            ['/api/transactions'],
            updatedQueryData
          );
          console.log(`Updated QueryClient cache - removed transaction ${id} and related instances`);
        }
        
        // Force view refresh by temporarily changing dates
        setTimeout(() => {
          const tempDate = new Date(currentDate);
          tempDate.setDate(tempDate.getDate() + 1);
          setSelectedDate(tempDate);
          
          setTimeout(() => {
            setSelectedDate(currentDate);
          }, 100);
        }, 100);
      } catch (error) {
        console.error('Error during client-side transaction deletion:', error);
      }
    } else {
      // For regular (non-hardcoded) transactions, use the mutation
      console.log(`Deleting regular transaction with ID: ${id}`);
      deleteTransaction.mutate(id);
    }
  };

  // Delete transaction mutation
  const deleteTransaction = useMutation({
    mutationFn: (id: number) => {
      // Regular transactions should use the DELETE request
      return apiRequest('DELETE', `/api/transactions/${id}`);
    },
    onSuccess: (_, id) => {
      // Also save to localStorage for consistent handling
      markTransactionAsDeleted(id);
      console.log(`Regular transaction ${id} deletion saved to localStorage`);
      
      // Show success message
      toast({
        title: "Success",
        description: "Transaction deleted successfully",
      });
      
      // Refresh data
      queryClient.invalidateQueries({ queryKey: ['/api/transactions'] });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: `Failed to delete transaction: ${error}`,
        variant: "destructive",
      });
    }
  });
  
  // Update transaction mutation
  const updateTransaction = useMutation({
    mutationFn: ({ id, data }: { id: number, data: Partial<Transaction> }) => {
      return apiRequest('PATCH', `/api/transactions/${id}`, data);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/transactions'] });
      setShowEditModal(false);
      setSelectedTransaction(null);
      toast({
        title: "Success",
        description: "Transaction updated successfully",
      });
    },
    onError: (error) => {
      toast({
        title: "Error", 
        description: `Failed to update transaction: ${error}`,
        variant: "destructive",
      });
    }
  });

  // Add savings mutation
  const addSavings = useMutation({
    mutationFn: (savingsData: Omit<Savings, "id">) => {
      return apiRequest('POST', '/api/savings', savingsData);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/savings'] });
      setShowSavingsModal(false);
      toast({
        title: "Success",
        description: "Savings added successfully",
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: `Failed to add savings: ${error}`,
        variant: "destructive",
      });
    }
  });
  
  // Fetch categories
  const { 
    data: categories = [], 
    isLoading: isLoadingCategories 
  } = useQuery<Category[]>({
    queryKey: ['/api/categories'],
  });
  
  // Fetch savings
  const { 
    data: savings = [], 
    isLoading: isLoadingSavings 
  } = useQuery<Savings[]>({
    queryKey: ['/api/savings'],
  });
  
  // Create hardcoded transactions (expenses and income) for demo/development
  const hardcodedExpenses = useMemo(() => createHardcodedExpenseTransactions(), []);
  const hardcodedIncome = useMemo(() => createHardcodedIncomeTransactions(), []);
  
  // Combine real and hardcoded transactions
  const allTransactions = useMemo(() => {
    const combined = [...transactions, ...hardcodedExpenses, ...hardcodedIncome];
    const transactionsWithEdits = applyUserEditsToTransactions(combined);
    return filterDeletedTransactions(transactionsWithEdits);
  }, [transactions, hardcodedExpenses, hardcodedIncome]);
  
  // Filter transactions based on date range
  const filteredTransactions = useMemo(() => {
    return allTransactions.filter(transaction => {
      if (!transaction.date) return false;
      const transactionDate = typeof transaction.date === 'string' 
        ? parseISO(transaction.date) 
        : transaction.date;
      return transactionDate >= dateRange.startDate && transactionDate <= dateRange.endDate;
    });
  }, [allTransactions, dateRange]);
  
  // Get unique transaction titles for autocomplete
  const uniqueTitles = useMemo(() => {
    const titles = allTransactions.map(t => t.title);
    return [...new Set(titles)];
  }, [allTransactions]);
  
  // Handle editing a transaction
  const handleEditTransaction = (transaction: TransactionWithCategory) => {
    setSelectedTransaction(transaction);
    setShowEditModal(true);
  };
    
  return (
    <div className="mx-auto px-2 sm:px-4 md:px-6 max-w-7xl py-4 md:py-8">
      <div className="flex flex-col w-full gap-4">
        {/* Header with time controls */}
        <div className="flex items-center justify-between flex-wrap gap-4">
          <h1 className="text-3xl font-bold tracking-tight">Expense Planner</h1>
          
          <div className="flex gap-2 flex-wrap">
            <TabsList className="grid grid-cols-3">
              <TabsTrigger 
                value="week" 
                onClick={() => setTimeframe("week")}
                data-state={timeframe === "week" ? "active" : "inactive"}
              >
                Week
              </TabsTrigger>
              <TabsTrigger 
                value="month" 
                onClick={() => setTimeframe("month")}
                data-state={timeframe === "month" ? "active" : "inactive"}
              >
                Month
              </TabsTrigger>
              <TabsTrigger 
                value="year" 
                onClick={() => setTimeframe("year")}
                data-state={timeframe === "year" ? "active" : "inactive"}
              >
                Year
              </TabsTrigger>
            </TabsList>
            
            <TabsList className="grid grid-cols-2">
              <TabsTrigger 
                value="calendar" 
                onClick={() => setView("calendar")}
                data-state={view === "calendar" ? "active" : "inactive"}
              >
                Calendar
              </TabsTrigger>
              <TabsTrigger 
                value="list" 
                onClick={() => setView("list")}
                data-state={view === "list" ? "active" : "inactive"}
              >
                List
              </TabsTrigger>
            </TabsList>
            
            <div className="flex gap-2">
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="outline" size="sm" onClick={() => setShowExpenseModal(true)}>
                      <Plus className="h-4 w-4 mr-1" />
                      Expense
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Add a new expense</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
              
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="outline" size="sm" onClick={() => setShowIncomeModal(true)}>
                      <Plus className="h-4 w-4 mr-1" />
                      Income
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Add new income</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
              
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="outline" size="sm" onClick={() => setShowSavingsModal(true)}>
                      <Plus className="h-4 w-4 mr-1" />
                      Savings
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Add to savings</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
          </div>
        </div>
        
        {/* Date range display */}
        <div className="text-lg font-semibold text-center">{dateRangeText}</div>
        
        {/* Main grid layout */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          {/* Left Column - Financial Summary */}
          <div className="md:col-span-1">
            <FinancialSummary 
              transactions={filteredTransactions}
              savings={savings}
              isLoading={isLoadingTransactions || isLoadingSavings}
              timeframe={timeframe}
              currentDate={selectedDate}
            />
          </div>
          
          {/* Center Column - Calendar or List View */}
          <div className="md:col-span-1">
            {view === "calendar" ? (
              <ExpenseCalendar
                transactions={filteredTransactions}
                onDateChange={setSelectedDate}
                selectedDate={selectedDate}
                onEditTransaction={handleEditTransaction}
                onDeleteTransaction={handleDeleteTransaction}
                isLoading={isLoadingTransactions}
              />
            ) : (
              <ExpenseList 
                transactions={filteredTransactions}
                categories={categories}
                onEditTransaction={handleEditTransaction}
                onDeleteTransaction={handleDeleteTransaction}
                isLoading={isLoadingTransactions}
              />
            )}
          </div>
          
          {/* Right Column */}
          <div className="grid grid-cols-1 gap-4">
            {/* Upcoming Expenses */}
            <UpcomingExpenses
              transactions={transactions}
              isLoading={isLoadingTransactions}
              onEditTransaction={handleEditTransaction}
              currentDate={selectedDate}
            />
            
            {/* Budget Coaching Companion */}
            <div className="mt-4">
              <BudgetCoachingCompanion
                transactions={transactions}
                isLoading={isLoadingTransactions}
                currentDate={selectedDate}
              />
            </div>
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="mt-6">
        <div className="space-y-6">
          <RecurringTransactions 
            transactions={allTransactions.filter(t => t.isRecurring)} 
            onEditTransaction={handleEditTransaction}
            onDeleteTransaction={handleDeleteTransaction}
            isLoading={isLoadingTransactions}
          />
        </div>
      </div>

      {/* Modals */}
      <AddExpenseModal
        isOpen={showExpenseModal}
        onClose={() => setShowExpenseModal(false)}
        onAddExpense={(data) => {
          // Ensure notes is never undefined
          const sanitizedData = {
            ...data,
            notes: data.notes || null,
            isExpense: true
          };
          addTransaction.mutate(sanitizedData);
        }}
        categories={categories.filter((c: Category) => c.isExpense)}
        isPending={addTransaction.isPending}
        titleSuggestions={uniqueTitles.filter(title => {
          // Find a transaction with this title to check if it's an expense
          const matchingTransaction = allTransactions.find(t => t.title === title);
          return matchingTransaction?.isExpense === true;
        })}
        defaultDate={selectedDate}
      />
      
      <AddIncomeModal
        isOpen={showIncomeModal}
        onClose={() => setShowIncomeModal(false)}
        onAddIncome={(data) => {
          // Ensure notes is never undefined
          const sanitizedData = {
            ...data,
            notes: data.notes || null,
            isExpense: false
          };
          addTransaction.mutate(sanitizedData);
        }}
        isPending={addTransaction.isPending}
        titleSuggestions={uniqueTitles.filter(title => {
          // Find a transaction with this title to check if it's income
          const matchingTransaction = allTransactions.find(t => t.title === title);
          return matchingTransaction?.isExpense === false;
        })}
      />
      
      <EditTransactionModal
        isOpen={showEditModal}
        onClose={() => {
          setShowEditModal(false);
          setSelectedTransaction(null);
        }}
        onUpdateTransaction={(id, data) => {
          // Extract relevant characteristics of the transaction
          const transactionTitle = selectedTransaction?.title || data.title || '';
          const isVirtualTransaction = id >= 970000;
          const isRecurringTransaction = data.isRecurring === true;
          const isRecurringChanged = selectedTransaction?.isRecurring !== data.isRecurring;
          const isAmountChanged = selectedTransaction?.amount !== data.amount;
          
          console.log(`Transaction update - ID: ${id}, Title: ${transactionTitle}, IsRecurring: ${isRecurringTransaction}, IsVirtual: ${isVirtualTransaction}`);
          
          // First, always save edits to localStorage for any recurring transaction (virtual or real)
          if (isRecurringTransaction || isVirtualTransaction) {
            console.log(`Handling recurring/virtual transaction update for ${id}`);
            
            // Get current data cache for working with transactions
            const currentQueryData = queryClient.getQueryData<TransactionWithCategory[]>(['/api/transactions']);
            if (!currentQueryData) {
              console.error("No transaction data in cache!");
              return;
            }
            
            // Find the transaction being edited
            const currentTransaction = currentQueryData.find(t => t.id === id);
            if (!currentTransaction) {
              console.error(`Couldn't find transaction ${id} in cache!`);
              return;
            }
            
            // Create the updated transaction with new values
            const updatedTransaction = { ...currentTransaction, ...data };
            
            // Special handling for recurring transactions
            if (isRecurringTransaction) {
              // Check if we're dealing with a recurring pattern that affects multiple transactions
              const isCoreRecurringChange = isAmountChanged || isRecurringChanged;
              
              if (isCoreRecurringChange) {
                console.log(`Making core change to recurring transaction pattern: ${updatedTransaction.title}`);
                
                // For a recurring pattern, find all related transactions with same title pattern
                const relatedTransactions = currentQueryData.filter(t => 
                  t.title === updatedTransaction.title && 
                  t.isExpense === updatedTransaction.isExpense
                );
                
                console.log(`Found ${relatedTransactions.length} related transactions to update`);
                
                // Update all instances matching the pattern in localStorage
                relatedTransactions.forEach(relatedTx => {
                  const relatedUpdate = { 
                    ...relatedTx, 
                    amount: data.amount ?? relatedTx.amount,
                    isRecurring: data.isRecurring ?? relatedTx.isRecurring,
                    recurringInterval: data.recurringInterval ?? relatedTx.recurringInterval
                  };
                  
                  // Save each related transaction to local storage
                  saveEditedTransaction(relatedUpdate);
                  console.log(`Saved related transaction #${relatedUpdate.id} with new amount: ${relatedUpdate.amount}`);
                });
                
                // Also update all instances in the cache
                const updatedQueryData = currentQueryData.map(t => {
                  // If this is the exact transaction being edited
                  if (t.id === id) {
                    return updatedTransaction;
                  }
                  
                  // If this is a related transaction with same title pattern
                  if (t.title === updatedTransaction.title && t.isExpense === updatedTransaction.isExpense) {
                    return { 
                      ...t, 
                      amount: data.amount ?? t.amount,
                      isRecurring: data.isRecurring ?? t.isRecurring,
                      recurringInterval: data.recurringInterval ?? t.recurringInterval
                    };
                  }
                  
                  return t;
                });
                
                // Update cache with all changes
                queryClient.setQueryData<TransactionWithCategory[]>(
                  ['/api/transactions'],
                  updatedQueryData
                );
                console.log(`Updated QueryClient cache for all related transactions`);
              } else {
                // Simple update for just this one recurring instance
                saveEditedTransaction(updatedTransaction);
                
                // Update just this transaction in cache
                const updatedQueryData = currentQueryData.map(t => 
                  t.id === id ? updatedTransaction : t
                );
                
                queryClient.setQueryData<TransactionWithCategory[]>(
                  ['/api/transactions'],
                  updatedQueryData
                );
              }
            } else {
              // Non-recurring virtual transaction
              saveEditedTransaction(updatedTransaction);
              
              // Update the cache with just this transaction
              const updatedQueryData = currentQueryData.map(t => 
                t.id === id ? updatedTransaction : t
              );
              
              queryClient.setQueryData<TransactionWithCategory[]>(
                ['/api/transactions'],
                updatedQueryData
              );
            }
            
            // Force refresh of the UI
            queryClient.invalidateQueries({ queryKey: ['/api/transactions'] });
            
            // Show success message
            toast({
              title: "Success",
              description: isRecurringTransaction 
                ? "Recurring transaction updated" 
                : "Transaction updated"
            });
            
            // Force a refresh by switching months temporarily (helps with calendar display)
            const currentDate = new Date(selectedDate);
            const refreshDate = new Date(currentDate);
            refreshDate.setDate(refreshDate.getDate() + 1); // Just one day forward is enough
            
            setTimeout(() => {
              setSelectedDate(refreshDate);
              setTimeout(() => {
                setSelectedDate(currentDate);
              }, 200);
            }, 100);
            
            // If it's a real database transaction (not virtual), also send to API
            if (!isVirtualTransaction) {
              console.log(`Also sending real transaction ${id} update to API`);
              updateTransaction.mutate({ id, data });
            }
            
            // Close the modal
            setShowEditModal(false);
            setSelectedTransaction(null);
          } else {
            // Regular non-recurring transaction update - just use the API
            console.log(`Regular transaction update for ${id}, sending to API`);
            updateTransaction.mutate({ id, data });
          }
        }}
        transaction={selectedTransaction}
        categories={categories}
        isPending={updateTransaction.isPending}
        titleSuggestions={uniqueTitles}
      />
      
      <AddSavingsModal
        isOpen={showSavingsModal}
        onClose={() => setShowSavingsModal(false)}
        onAddSavings={(data) => {
          // Ensure notes is never undefined
          const sanitizedData = {
            ...data,
            notes: data.notes || null
          };
          addSavings.mutate(sanitizedData);
        }}
        isPending={addSavings.isPending}
      />
    </div>
  );
}